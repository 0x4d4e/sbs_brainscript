% Brainfuck interpreter/debugger in Postscript
%
%
%
% Fabian Gr√ºnbichler - 0828562
% Matthias Neumayr 	 - 0825199
%


/max-size 30000 def
/output max-size string def


% helpers
/over   { 1 index 					     } bind def
/rot    { 3 -1 roll                      } bind def
/dec    { 1 sub                          } bind def
/inc    { 1 add                          } bind def
/nip    { exch pop                       } bind def
/flip   { 2 1 roll                       } bind def
/2swap  { 4 2 roll						 } bind def


/read-file
%Stack: filename -- content
{ (r) file max-size string readstring {(code zu lang) =} if } def


/read-stdin
% Stack: -- char
% TODO: fails if more than one char, read more and throw rest away?
{ (%stdin) (r) file 1 string readstring false eq {(input error) =} if } def


/str-to-array
% Stack: (str) -- [ chars ]
{
	/l over length def
 	{} forall l array astore		% expand string on stack and store into array
} def


/print-char
% Stack: int --
% Output: char
{
	( ) dup 0
	4 3 roll put
	=only
} def



/init-array
% Stack: array init_value -- initialized_array
{
	exch dup 						% v a a
	3 1 roll 						% a v a
	dup 0 1 3 2 roll length 1 sub 	% a v a 0 1 l-1
	{ 								% a v a i
		2 copy 						% a v a i a i
		4 index 					% a v a i a i v
		put pop 					% a v a
	} for
	pop pop 						% a
} def


/case
% Stack: dict key -- execute dict value
{
	2 copy							% make copy of dict and value
	known not 						% check if value not in dict
	{ pop /Default }if				% get default value
	get exec 						% get and exec dict value otherwise
} bind def











% Dict of Brainfuck commands and their corresponding execution tokens
/bf-commands
<<
49 {(hello)=}							% 1

43 {(handle +)=}						% +
45 {(handle -)=}						% -

44 {(handle ,)=}						% ,
46 {(handle .)=}						% .

60 {(handle <)=}						% <
62 {(handle >)=}						% >

91 {(handle [)=}						% [
93 {(handle ])=}						% ]

/Default {(not implemented)=}
>> def




/bf-handle-command
% Stack: command --
{
	//bf-commands exch					% <<commands>> command
	case
} def



/bf-step
% Stack: [tape] ti [code] ci --[tape] tin [code] cin
{
	2 copy							% [t] ti [c] ci [c] ci
	get								% .....         command
	(> ) print dup print-char 		% print current command
	( : ) print
	bf-handle-command				% interpret current command
} def



/bf-init-tape
% Stack: -- [tape]
{
	max-size array
	0 init-array
} def


/bf-read-file
% Stack: % (filename) -- [code]
{
	read-file
	str-to-array
} def


/bf-run-file
% Stack (filename) --
{
	bf-read-file 0			% [code] 0
	bf-init-tape 0			% [code] 0 [tape] 0
	2swap					% [tape] 0 [code] 0
	%...
} def



/bf-run
% Stack: (input) --
{
	str-to-array 0				% [code] 0
	bf-init-tape 0				% [code] 0 [tape] 0
	2swap						% [tape] 0 [code] 0
	% ....
} def