%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Brainfuck interpreter/debugger in Postscript
%
%
%
% Fabian Gr√ºnbichler - 0828562
% Matthias Neumayr 	 - 0825199
%
%





% TODO: 
%	- output/graphics
%	- modes (stepwise, continue, )
% 	- breakpoints (#)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Globals

/max-size 1024 def
/output max-size string def



/err-loop { (\nFailed to find matching ']'!) = } def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Helpers

/over   { 1 index 					     } bind def
/rot    { 3 -1 roll                      } bind def
/dec    { 1 sub                          } bind def
/inc    { 1 add                          } bind def
/nip    { exch pop                       } bind def
/flip   { 2 1 roll                       } bind def
/2swap  { 4 2 roll						 } bind def


/read-file
% Stack: (filename) --(content)
{ 
	(r) file max-size string readstring {(input too long) =} if
} def


/read-stdin
% Stack: -- (char)
% TODO: fails if more than one char, read more and throw rest away?
{
	(%stdin) (r) file 1 string readstring false eq {(input error) =} if
} def


/str-to-array
% Stack: (str) -- [ chars ]
{
	/l over length def
 	{} forall l array astore		% expand string on stack and store into array
} def


/print-char
% Stack: int --
% Output: char
{
	( ) dup 0
	4 3 roll put
	=only
} def


/init-array
% Stack: array init_value -- initialized_array
{
	exch dup 						% v a a
	3 1 roll 						% a v a
	dup 0 1 3 2 roll length 1 sub 	% a v a 0 1 l-1
	{ 								% a v a i
		2 copy 						% a v a i a i
		4 index 					% a v a i a i v
		put pop 					% a v a
	} for
	pop pop 						% a
} def


/case
% Stack: dict key -- execute dict value
{
	2 copy							% make copy of dict and value
	known not 						% check if value not in dict
	{ pop /Default }if				% get default value
	get exec 						% get and exec dict value otherwise
} bind def






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% brainfuck interpretation




/increment
% Stack: tape ti code ci -- tape([ti] + 1) ti code ci+1
{
	2swap
	2 copy 2 copy						% 2 copies for get and put
	get inc	put							% get value, increment & store back
	2swap								% swap tape/code back
	inc									% increment code index
} def



/decrement
% Stack: tape ti code ci -- tape([ti] - 1) ti code ci+1
{
	2swap
	2 copy 2 copy
	get dec put
	2swap
	inc
} def



/print
% prints char at current tape cell
% TODO: store output
% Stack: tape ti code ci -- tape ti code ci+1
% Output: current cell as ASCII char
{
	2swap
	2 copy get print-char
	2swap
	inc
} def


/read
% reads input from stdin and stores in current tape cell
{
	2swap 2 copy
	read-stdin {} forall 					% assume only one char here
	put
	2swap
	inc
} def



/right
% Stack: tape ti code ci -- tape ti+1 code ci+1
{
	inc										% ci + 1
	2swap
	inc-tape								% ti + 1
	2swap
} def



/inc-tape
% Stack: [tape] ti -- [tape] ti+1
{
	inc
	2 copy exch length ge						% ge just to be safe
	{ mark 3 -1 roll aload pop 0 ] exch } if 	% grow tape 1 element if index equal length
} def



/left
% TODO: check underflow, tape index < 0
% Stack: tape ti code ci -- tape ti-1 code ci+1
{
	inc 									% ci + 1
	2swap
	dec 									% ti - 1
	2swap
} def



/jump
{
	2swap							% get tape
	2 copy get 0 eq 				% compare current value to 0
	{
		2swap jump-loop 			% if 0 -> move instruction pointer after ]
		{ inc }
		{ err-loop } ifelse
	}
	{
		2swap inc 					% else move ip + 1
	} ifelse
} def



/jump-loop
% Stack: code ci -- code ci-next success
% TODO: add boolean return value for success status
{
	/lc 1 def 						% loopcount

	inc over length dec 1 exch		% run from ci+1 to ] or end
	{
		2 copy get					% get command at index
		dup 91 eq {
			/lc lc inc def 			% increment lc for every [ found
		}if
		dup 93 eq {
			/lc lc dec def 			% decrement lc for every ] found
		}if
		pop 						% remove current code value

		lc 0 eq 					% check loopcount
		{ exit }					% exit and leave loop index on stack
		{ pop } 					% remove loop index if matching ] not found
		ifelse
	} for

	lc 0 eq dup false eq {exch dup length 3 -1 roll} if
} def



/loop-e
{
	(TODO: handle ]) = exit
} def



% Dict of brainfuck commands and their corresponding execution tokens
/bf-commands
<<
	43 		{ increment }						% +
	45 		{ decrement }						% -

	44 		{ read }							% ,
	46 		{ print }							% .

	60 		{ left }							% <
	62 		{ right }							% >

	91 		{ jump }							% [
	93 		{ loop }							% ]

	%TODO: # as breakpoint, ! sometimes recognised (??)

	/Def 	{(not implemented) = exit}
>> def



/bf-handle-command
% Stack: command --
{
	//bf-commands exch					% <<commands>> command
	case
} def



/bf-check-end
% Stack: [tape] ti [code] ci -- [tape] ti [code] ci true/false
{
	2 copy
	exch
	length
	eq
	{ true } { false } ifelse
} def



/bf-step
% Stack: [tape] ti [code] ci --[tape] tin [code] cin
{
	2 copy							% [t] ti [c] ci [c] ci
	get								% .....         command
	%(> ) print dup print-char 		% print current command
	%( : ) print
	bf-handle-command				% interpret current command
} def



/bf-continue
{
	{
		bf-step

		bf-check-end
		{ (\nend of code reached!)= exit } if
	} loop
} def



%/bf-init-tape
% Stack: -- [tape]
%{
%	1 array
%	0 init-array
%} def



/bf-start
% Stack: [code] 0 --
{
	[0] 0					% [code] 0 [tape] 0
	2swap					% [tape] 0 [code] 0

%TODO: modes (stepwise/continue/...)

	bf-continue
} def




/bf-run-file
% Stack (filename) --
{
	read-file

	bf-run
} def



/bf-run
% Stack: (input) --
{
	dup length 0 eq {(Empty input!\n)= clear stop} if

	str-to-array 0			% [code] 0
	bf-start

	%clear
	%()=						% newline at end of execution
} def