% Brainfuck interpreter/debugger in Postscript
%
%
%
% Fabian Gr√ºnbichler - 0828562
% Matthias Neumayr 	 - 0825199
%

/max-size 30000 def

% helpers
/over   { 1 index 					     } bind def
/2dup   { 2 copy                         } bind def
/rot    { 3 -1 roll                      } bind def
/dec    { 1 sub                          } bind def
/inc    { 1 add                          } bind def
/nip    { exch pop                       } bind def
/flip   { 2 1 roll                       } bind def


/read-file
%Stack: filename -- content
{ (r) file max-size string readstring {(code zu lang) =} if } def


/read-stdin
% Stack: -- char
% TODO: fails if more than one char, read more and throw rest away?
{ (%stdin) (r) file 1 string readstring false eq {(input error) =} if } def


/str-to-array
% Stack: (str) -- [ chars ]
{
	/l over length def
 	{} forall l array astore
} def


/print-char
% Stack: int --
% Output: char
{
	( ) dup 0
	4 3 roll put
	=only
} def



/init-array
% Stack: array init_value -- initialized_array
{
	exch dup 						% v a a
	3 1 roll 						% a v a
	dup 0 1 3 2 roll length 1 sub 	% a v a 0 1 l-1
	{ 								% a v a i
		2 copy 						% a v a i a i
		4 index 					% a v a i a i v
		put pop 					% a v a
	} for
	pop pop 						% a
} def



/bf-read-file
% Stack: % (filename) -- array 0
{
	read-file
	str-to-array
	0
} def



/bf-init-tape
% Stack: -- tape 0
{
	max-size array
	0 init-array
	0
} def



/bf-run-file {
	bf-read-file	% (code) 0
	bf-init-tape	% (code) 0 [ tape ] 0
	%...
} def






% (code) -- 
/bf-run {
	str-to-array 0	% (code) 0
	bf-init-tape	% (code) 0 tape 0
	%...
} def